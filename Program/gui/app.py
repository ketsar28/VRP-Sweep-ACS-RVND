"""Streamlit GUI for MFVRPTW final results.

The application presents pre-computed routing outcomes generated by the
MFVRPTW pipeline (Sweep â†’ NN â†’ ACS â†’ RVND). No optimisation is performed here;
all data is consumed from existing artifacts.
"""

from __future__ import annotations

import json
import sys
import threading
import time
import importlib.util
from pathlib import Path
from typing import Dict, List

import pandas as pd
import plotly.graph_objects as go
import streamlit as st

# Compatibility fallback: some Streamlit versions expose `data_editor` instead
# of `experimental_data_editor`. Ensure the code in tabs using
# `st.experimental_data_editor` keeps working across versions.
if not hasattr(st, "experimental_data_editor") and hasattr(st, "data_editor"):
    st.experimental_data_editor = st.data_editor


def _load_agents_module() -> object:
    agents_path = Path(__file__).resolve().parent / "agents.py"
    spec = importlib.util.spec_from_file_location("gui_agents", agents_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)  # type: ignore
    return module


# Add tabs folder to path for imports
_tabs_dir = Path(__file__).resolve().parent / "tabs"
if str(_tabs_dir) not in sys.path:
    sys.path.insert(0, str(_tabs_dir))

try:
    from input_titik import render_input_titik
except ImportError as e:
    st.error(f"Error loading Input Titik: {e}")
    def render_input_titik(): return st.error("Input Titik module not found")

try:
    from input_data import render_input_data
except ImportError as e:
    st.error(f"Error loading Input Data: {e}")
    def render_input_data(): return st.error("Input Data module not found")

try:
    from hasil import render_hasil
except ImportError as e:
    st.error(f"Error loading Hasil: {e}")
    def render_hasil(): return st.error("Hasil module not found")

try:
    from graph_hasil import render_graph_hasil
except ImportError as e:
    st.error(f"Error loading Graph Hasil: {e}")
    def render_graph_hasil(): return st.error("Graph Hasil module not found")

try:
    from academic_replay_tab import render_academic_replay
except ImportError as e:
    # Silently handle - academic replay is optional
    render_academic_replay = None


def _build_state_from_parsed(instance: Dict, parsed_distance: Dict) -> Dict:
    points = {"depots": [], "customers": []}
    if "depot" in instance:
        points["depots"].append(instance["depot"])
    for cust in instance.get("customers", []):
        points["customers"].append(cust)

    inputData = {
        "customerDemand": [c.get("demand", 0) for c in instance.get("customers", [])],
        "distanceMatrix": parsed_distance.get("distance_matrix", []),
    }
    return {"points": points, "inputData": inputData}


def _build_state_from_ui() -> Dict:
    """Construct the coordinator state from Streamlit session_state (UI editors).

    Looks for `points` and `inputData` (or individual `distanceMatrix` / `customerDemand`).
    """
    pts = st.session_state.get("points", {})
    input_data = st.session_state.get("inputData") or {}
    # fallback individual keys
    if not input_data:
        input_data = {}
        if "distanceMatrix" in st.session_state:
            input_data["distanceMatrix"] = st.session_state.get(
                "distanceMatrix")
        elif "distance_matrix" in st.session_state:
            input_data["distanceMatrix"] = st.session_state.get(
                "distance_matrix")
        if "customerDemand" in st.session_state:
            input_data["customerDemand"] = st.session_state.get(
                "customerDemand")
        elif "demands" in st.session_state:
            input_data["customerDemand"] = st.session_state.get("demands")
    return {"points": pts, "inputData": input_data}


BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "data" / "processed"
DOCS_DIR = BASE_DIR / "docs"

FINAL_SOLUTION_PATH = DATA_DIR / "final_solution.json"
FINAL_SUMMARY_PATH = DOCS_DIR / "final_summary.md"
PARSED_INSTANCE_PATH = DATA_DIR / "parsed_instance.json"
PARSED_DISTANCE_PATH = DATA_DIR / "parsed_distance.json"


def load_json(path: Path) -> Dict:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def read_markdown(path: Path) -> str:
    with path.open("r", encoding="utf-8") as handle:
        return handle.read()


def parse_markdown_table(markdown_text: str, header: str) -> pd.DataFrame:
    """Extract table that immediately follows the given markdown header."""
    lines = markdown_text.splitlines()
    table_lines: List[str] = []
    capture = False
    for line in lines:
        if line.strip().startswith("##") and header.lower() in line.strip().lower():
            capture = True
            continue
        if capture:
            if not line.strip():
                break
            table_lines.append(line)
    if not table_lines:
        return pd.DataFrame()

    # First line contains header row, second contains separator
    header_row = [cell.strip()
                  for cell in table_lines[0].split("|") if cell.strip()]
    data_rows = []
    for row in table_lines[2:]:
        cells = [cell.strip() for cell in row.split("|") if cell.strip()]
        if cells:
            data_rows.append(cells)
    return pd.DataFrame(data_rows, columns=header_row)


def prepare_route_table(final_solution: Dict, instance_data: Dict) -> pd.DataFrame:
    fleet_lookup = {fleet["id"]: fleet for fleet in instance_data["fleet"]}
    rows = []
    for route in final_solution["routes"]:
        vehicle = fleet_lookup[route["vehicle_type"]]
        fixed_cost = vehicle["fixed_cost"]
        variable_cost = vehicle["variable_cost_per_km"] * \
            route["total_distance"]
        rows.append(
            {
                "Cluster": route["cluster_id"],
                "Vehicle": route["vehicle_type"],
                "Route": " â†’ ".join(map(str, route["sequence"])),
                "Distance (km)": round(route["total_distance"], 3),
                "Time (min)": round(route["total_time_component"], 3),
                "TW Violation (min)": round(route["total_tw_violation"], 3),
                "Objective": round(route["objective"], 3),
                "Cost (Rp)": round(fixed_cost + variable_cost, 2),
            }
        )
    return pd.DataFrame(rows)


def build_route_plot(final_solution: Dict, instance_data: Dict) -> go.Figure:
    nodes = {instance_data["depot"]["id"]: instance_data["depot"]}
    nodes.update({cust["id"]: cust for cust in instance_data["customers"]})

    depot_id = instance_data["depot"]["id"]

    fig = go.Figure()

    colour_palette = [
        "#1f77b4",
        "#ff7f0e",
        "#2ca02c",
        "#d62728",
        "#9467bd",
        "#8c564b",
        "#e377c2",
        "#7f7f7f",
        "#bcbd22",
        "#17becf",
    ]

    for index, route in enumerate(final_solution["routes"]):
        colour = colour_palette[index % len(colour_palette)]
        seq = route["sequence"]
        x_values = [nodes[node_id]["x"] for node_id in seq]
        y_values = [nodes[node_id]["y"] for node_id in seq]

        hover_text = []
        for node_id in seq:
            node = nodes[node_id]
            if node_id == depot_id:
                demand = "-"
                tw_start = instance_data["depot"]["time_window"]["start"]
                tw_end = instance_data["depot"]["time_window"]["end"]
            else:
                demand = node["demand"]
                tw_start = node["time_window"]["start"]
                tw_end = node["time_window"]["end"]
            hover_text.append(
                f"Node {node_id}<br>Demand: {demand}<br>TW: {tw_start} â€“ {tw_end}"
            )

        fig.add_trace(
            go.Scatter(
                x=x_values,
                y=y_values,
                mode="lines+markers",
                name=f"Cluster {route['cluster_id']} ({route['vehicle_type']})",
                line=dict(color=colour, width=3),
                marker=dict(size=10),
                hoverinfo="text",
                text=hover_text,
            )
        )

    depot = nodes[depot_id]
    fig.add_trace(
        go.Scatter(
            x=[depot["x"]],
            y=[depot["y"]],
            mode="markers",
            name="Depot",
            marker=dict(size=14, color="#000000", symbol="diamond"),
            hoverinfo="text",
            text=["Depot"],
        )
    )

    fig.update_layout(
        title="Route Layout",
        xaxis_title="X Coordinate",
        yaxis_title="Y Coordinate",
        legend=dict(title="Clusters"),
        template="plotly_white",
        height=650,
    )
    return fig


def render_kpis(summary: Dict) -> None:
    st.markdown("## Key Performance Indicators")
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Total Distance (km)", f"{summary['total_distance']:.3f}")
    col2.metric("Total Cost (Rp)", f"{summary['total_cost']:,.0f}")
    col3.metric("TW Violations (min)", f"{summary['total_tw_violation']:.3f}")
    fleet_usage = ", ".join(
        f"{ftype}: {summary['fleet_usage'][ftype]}"
        for ftype in sorted(summary["fleet_usage"].keys())
    )
    col4.metric("Fleet Usage", fleet_usage)


def render_cluster_details(route_table: pd.DataFrame) -> None:
    st.markdown("## Cluster Detail")
    for _, row in route_table.sort_values("Cluster").iterrows():
        with st.expander(f"Cluster {row['Cluster']} â€“ Vehicle {row['Vehicle']}"):
            st.write(
                {
                    "Route": row["Route"],
                    "Distance (km)": row["Distance (km)"],
                    "Time (min)": row["Time (min)"],
                    "TW Violation (min)": row["TW Violation (min)"],
                    "Objective": row["Objective"],
                    "Cost (Rp)": row["Cost (Rp)"]
                }
            )


def render_comparison_table(final_summary_md: str) -> None:
    comparison_df = parse_markdown_table(final_summary_md, "ACS vs.")
    if comparison_df.empty:
        st.warning("ACS vs. RVND comparison table not found in summary.")
        return
    st.markdown("## ACS vs. RVND Comparison")
    comparison_df = comparison_df.replace({"**": ""}, regex=False)
    if "Cluster" in comparison_df.columns:
        comparison_df["Cluster"] = comparison_df["Cluster"].str.replace(
            "**", "", regex=False)
    numeric_columns = [
        col for col in comparison_df.columns if col not in {"Cluster"}]
    for column in numeric_columns:
        comparison_df[column] = (
            comparison_df[column]
            .str.replace(",", "")
            .str.replace("**", "", regex=False)
            .astype(float)
        )
    st.dataframe(
        comparison_df.style.format({col: "{:.3f}" for col in numeric_columns})
    )


def render_export_section(final_solution: Dict, route_table: pd.DataFrame, final_summary_md: str) -> None:
    st.markdown("## Export")
    col1, col2 = st.columns(2)
    with col1:
        st.download_button(
            "Download final_solution.json",
            data=json.dumps(final_solution, indent=2).encode("utf-8"),
            file_name="final_solution.json",
            mime="application/json",
        )
    with col2:
        csv_data = route_table.to_csv(index=False).encode("utf-8")
        st.download_button(
            "Download per-cluster summary (CSV)",
            data=csv_data,
            file_name="cluster_summary.csv",
            mime="text/csv",
        )
    st.download_button(
        "Download Markdown summary",
        data=final_summary_md.encode("utf-8"),
        file_name="final_summary.md",
        mime="text/markdown",
    )


def main() -> None:
    st.set_page_config(page_title="MFVRPTW Route Optimisation", layout="wide")

    # Theme toggle in sidebar
    st.sidebar.markdown("## ğŸ¨ Theme")
    theme_options = ["ğŸŒ™ Dark", "â˜€ï¸ Light"]

    # Initialize theme in session state
    if "app_theme" not in st.session_state:
        st.session_state.app_theme = "ğŸŒ™ Dark"

    selected_theme = st.sidebar.radio(
        "Choose theme:",
        theme_options,
        index=theme_options.index(st.session_state.app_theme),
        horizontal=True,
        key="theme_selector"
    )
    st.session_state.app_theme = selected_theme

    # Apply theme using custom CSS
    if selected_theme == "ğŸŒ™ Dark":
        st.markdown("""
        <style>
            /* Dark theme */
            .stApp {
                background-color: #0E1117;
                color: #FAFAFA;
            }
            .stSidebar {
                background-color: #262730;
            }
            .stTabs [data-baseweb="tab-list"] {
                background-color: #262730;
            }
            .stTabs [data-baseweb="tab"] {
                color: #FAFAFA;
            }
            .stMarkdown, .stText, p, span, label, h1, h2, h3, h4, h5, h6 {
                color: #FAFAFA !important;
            }
            .stDataFrame {
                background-color: #262730;
            }
            .stExpander {
                background-color: #262730;
                border-color: #4A4A5A;
            }
            .stMetric {
                background-color: #262730;
                border-radius: 10px;
                padding: 10px;
            }
            .stMetric label {
                color: #B0B0B0 !important;
            }
            .stMetric [data-testid="stMetricValue"] {
                color: #FAFAFA !important;
            }
            div[data-testid="stSidebarContent"] {
                background-color: #262730;
            }
            .stButton>button {
                background-color: #FF6B6B;
                color: white;
                border: none;
            }
            .stButton>button:hover {
                background-color: #FF8585;
            }
        </style>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <style>
            /* Light theme */
            .stApp {
                background-color: #FFFFFF;
                color: #262730;
            }
            .stSidebar {
                background-color: #F0F2F6;
            }
            .stTabs [data-baseweb="tab-list"] {
                background-color: #F0F2F6;
            }
            .stTabs [data-baseweb="tab"] {
                color: #262730;
            }
            .stMarkdown, .stText, p, span, label, h1, h2, h3, h4, h5, h6 {
                color: #262730 !important;
            }
            .stDataFrame {
                background-color: #FFFFFF;
            }
            .stExpander {
                background-color: #F0F2F6;
                border-color: #D0D0D0;
            }
            .stMetric {
                background-color: #F0F2F6;
                border-radius: 10px;
                padding: 10px;
            }
            .stMetric label {
                color: #666666 !important;
            }
            .stMetric [data-testid="stMetricValue"] {
                color: #262730 !important;
            }
            div[data-testid="stSidebarContent"] {
                background-color: #F0F2F6;
            }
            .stButton>button {
                background-color: #FF6B6B;
                color: white;
                border: none;
            }
            .stButton>button:hover {
                background-color: #FF8585;
            }
        </style>
        """, unsafe_allow_html=True)

    st.sidebar.markdown("---")

    st.title("MFVRPTW Route Optimization")
    st.caption("Sweep â†’ NN â†’ ACS â†’ RVND")

    # Top-level tabs: input editors, results, and academic replay
    if render_academic_replay is not None:
        tab1, tab2, tab3, tab4, tab5 = st.tabs(
            ["Input Titik", "Input Data", "Hasil", "Graph Hasil", "ğŸ“š Academic Replay"])
    else:
        tab1, tab2, tab3, tab4 = st.tabs(
            ["Input Titik", "Input Data", "Hasil", "Graph Hasil"])
        tab5 = None

    with tab1:
        render_input_titik()
    with tab2:
        render_input_data()
    with tab3:
        render_hasil()
    with tab4:
        render_graph_hasil()
    if tab5 is not None:
        with tab5:
            render_academic_replay()

    if not FINAL_SOLUTION_PATH.exists() or not FINAL_SUMMARY_PATH.exists():
        st.error(
            "Required artifacts not found. Please ensure preprocessing has been completed.")
        return

    # Try to load existing artifacts if present (optional)
    final_solution = load_json(
        FINAL_SOLUTION_PATH) if FINAL_SOLUTION_PATH.exists() else None
    final_summary_md = read_markdown(
        FINAL_SUMMARY_PATH) if FINAL_SUMMARY_PATH.exists() else ""
    instance_data = load_json(
        PARSED_INSTANCE_PATH) if PARSED_INSTANCE_PATH.exists() else None

    # Pipeline control (validate + run)
    st.sidebar.markdown("## Pipeline Control")
    agents = _load_agents_module()

    # Prefer UI-driven state when available
    state_ui = _build_state_from_ui()
    has_ui_points = bool(state_ui.get("points") and (
        state_ui["points"].get("customers") or state_ui["points"].get("depots")
    ))
    has_ui_input = bool(state_ui.get("inputData") and (
        state_ui["inputData"].get(
            "distanceMatrix") or state_ui["inputData"].get("customerDemand")
    ))

    if has_ui_points and has_ui_input:
        st.sidebar.markdown("### From UI editors")
        if st.sidebar.button("Validate UI inputs"):
            valid, errors = agents.validate_state(state_ui)
            st.session_state["pipeline_validated_ui"] = valid
            st.session_state["pipeline_errors_ui"] = errors
            if not valid:
                for e in errors:
                    st.sidebar.error(e)
            else:
                st.sidebar.success(
                    "Validasi sukses â€” pipeline dapat dijalankan (UI)")

        if st.session_state.get("pipeline_validated_ui", False):
            if st.sidebar.button("Run pipeline (from UI state)"):
                # start background thread to run pipeline and stream progress
                if not st.session_state.get("pipeline_running", False):
                    st.session_state["pipeline_running"] = True
                    st.session_state.setdefault("pipeline_log", [])

                    def _progress_cb(line: str):
                        st.session_state.pipeline_log.append(line)
                        if isinstance(line, str) and line.startswith("PROGRESS:"):
                            parts = line.split(":", 3)
                            if len(parts) >= 3:
                                try:
                                    pct = int(parts[2])
                                    st.session_state["pipeline_percent"] = pct
                                    st.session_state["pipeline_status"] = "running"
                                except Exception:
                                    pass

                    def _runner():
                        try:
                            res = agents.run_pipeline(
                                state_ui, progress_callback=_progress_cb)
                            st.session_state["last_pipeline_result"] = res
                            st.session_state["pipeline_status"] = "finished"
                        except Exception as exc:
                            st.session_state["pipeline_status"] = f"failed: {exc}"
                        finally:
                            st.session_state["pipeline_running"] = False

                    thread = threading.Thread(target=_runner, daemon=True)
                    thread.start()

                else:
                    st.sidebar.info("Pipeline sudah berjalan")

    # Fallback: operate on parsed files when UI editors not used
    st.sidebar.markdown("---")
    if st.sidebar.button("Validate parsed inputs"):
        if not PARSED_INSTANCE_PATH.exists():
            st.sidebar.error("parsed_instance.json missing")
        elif not PARSED_DISTANCE_PATH.exists():
            st.sidebar.error("parsed_distance.json missing")
        else:
            parsed_inst = load_json(PARSED_INSTANCE_PATH)
            parsed_dist = load_json(PARSED_DISTANCE_PATH)
            state = _build_state_from_parsed(parsed_inst, parsed_dist)
            valid, errors = agents.validate_state(state)
            st.session_state["pipeline_validated"] = valid
            st.session_state["pipeline_errors"] = errors
            if not valid:
                for e in errors:
                    st.sidebar.error(e)
            else:
                st.sidebar.success(
                    "Validasi sukses â€” pipeline dapat dijalankan")

    if st.session_state.get("pipeline_validated", False):
        if st.sidebar.button("Run pipeline (from parsed files)"):
            if not st.session_state.get("pipeline_running", False):
                st.session_state["pipeline_running"] = True
                st.session_state.setdefault("pipeline_log", [])

                parsed_inst = load_json(PARSED_INSTANCE_PATH)
                parsed_dist = load_json(PARSED_DISTANCE_PATH)

                def _progress_cb(line: str):
                    st.session_state.pipeline_log.append(line)
                    if isinstance(line, str) and line.startswith("PROGRESS:"):
                        parts = line.split(":", 3)
                        if len(parts) >= 3:
                            try:
                                pct = int(parts[2])
                                st.session_state["pipeline_percent"] = pct
                                st.session_state["pipeline_status"] = "running"
                            except Exception:
                                pass

                def _runner_parsed():
                    try:
                        res = agents.run_pipeline(_build_state_from_parsed(
                            parsed_inst, parsed_dist), progress_callback=_progress_cb)
                        st.session_state["last_pipeline_result"] = res
                        st.session_state["pipeline_status"] = "finished"
                    except Exception as exc:
                        st.session_state["pipeline_status"] = f"failed: {exc}"
                    finally:
                        st.session_state["pipeline_running"] = False

                thread = threading.Thread(target=_runner_parsed, daemon=True)
                thread.start()
            else:
                st.sidebar.info("Pipeline sudah berjalan")

    # If a pipeline run produced a fresh result, prefer it for display
    if st.session_state.get("last_pipeline_result"):
        st.session_state.setdefault(
            "result", st.session_state.get("last_pipeline_result"))

    # Pipeline runtime status and logs
    status = st.session_state.get("pipeline_status", "idle")
    running = st.session_state.get("pipeline_running", False)
    if running:
        st.sidebar.markdown("### Pipeline running")
        st.sidebar.info("Pipeline is running in background")
    pct = st.session_state.get("pipeline_percent", 0)
    if pct:
        st.sidebar.progress(pct)
    if st.session_state.get("pipeline_log"):
        with st.sidebar.expander("Pipeline Log", expanded=False):
            for line in st.session_state.pipeline_log[-200:]:
                st.text(line)
    if status.startswith("failed"):
        st.sidebar.error(status)
    elif status == "finished":
        st.sidebar.success("Pipeline finished â€” results loaded")

    st.sidebar.header("About")
    st.sidebar.info(
        "This dashboard provides UI for manual inputs and displays stored results. "
        "Computation runs only when triggered from the 'Input Data' menu."
    )


if __name__ == "__main__":
    main()
